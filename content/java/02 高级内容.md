高级应用
-----------------------
# 反射
包：`java.lang.reflect`

````
import java.lang.reflect.*;

import Hello.*;

public class tst {
	public static void main(String[] arg) {
		Class tp = Human.class;
		System.out.println("package name:" + tp.getPackageName());
		System.out.println("class name:" + tp.getSimpleName());

		System.out.println("-----------------------------------------");
		// 获取所有public字段
		for (Field f : tp.getFields()) {
			System.out.println("field name:" + f.getName());
		}

		System.out.println("-----------------------------------------");
		// 获取public方法
		for (Method m : tp.getMethods()) {
			System.out.println("method name:" + m.getName());
		}

		System.out.println("-----------------------------------------");
		// 获取所有所有字段
		for (Field f : tp.getDeclaredFields()) {
			System.out.println("field name:" + f.getName());
		}

		// 获取所有方法
		for (Method m : tp.getDeclaredMethods()) {
			System.out.println("method name:" + m.getName());
		}
	}

}
````

* get+功能名()的方法只获取包含基类的public成员:`getFields()`

* getDeclared+功能名()的方法获取当前类定义的所有成员，包含非public的。但不包含父类的成员:`getDeclaredFields()`

* getConstructor访问构造函数

## Annotation功能
Annotation是一种给代码添加一些静态元数据的一种方式，和C#的自定义特性是一样的
````
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 定义Annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
	String value();
	
	Class type();
}

// 使用Annotation
@MyAnnotation(value = "nihao", type = Human.class)
public class Human {}

// 访问类中的Annotation
public class tst {
	public static void main(String[] arg) {
		Class tp = Human.class;
		var annotationObj= (MyAnnotation)tp.getAnnotation(MyAnnotation.class);
		
		System.out.println(annotationObj.value());
		System.out.println(annotationObj.type().getName());
	}
}
````
* 实际Annotation是一个继承自`java.lang.annotation.Annotation`的接口，使用`@interface`定义

* 使用@target来标记针对的目标类型，参数取值为ElementType

* 使用@RetentionPolicy来标记Annotation信息的有效范围。参数取值RetentionPolicy

* 使用反射中Class类的函数:`getAnnotation`(获取),`isAnnotationPresent`(是否存在)等函数访问   

* 如果只有一个字段，且名为value，则可以不指定字段名 


![](image/ElementType.png)
![](image/RetentionPolicy.png)

# 枚举
````
public enum HumanEnum {
	Man,
	Woman
}

public enum HumanEnum2 {
	Man(1), //// 使用构造函数HumanEnum(int val)初始化
	Woman(2);

	public int value;
	
	private HumanEnum(int val){
		this.value = val;
	}
}
````

* 可以把枚举看成一个类，所有枚举都继承自`java.lang.Enum`

* 枚举可以有构造函数，但是枚举的构造函数都必须是private，此时，枚举项都需要调用对应构造函数声明枚举项

* 枚举也可以有字段，和普通类定义一致

* 默认的类型是整型

# 泛型

````
public class TestClass<T1 extends List,T2>{
	private T1 obj;
	private T2 obj2;
}
````  
* 使用`extends`限制泛型的类型，不管是类还是接口，都需要使用`extends`关键字

* 定义某个变更时，使用通配符`?`限制具体类型必须实现某个接口或继承某个类:`A<? extends List> a=new new A<ArrayList>();`。如果实例化的类型不是指定的子类或接口实现，将无法编译通过

* 继承过程中，如果没有指定泛型类型，则就相当于是Object
````
public class ExtendClass<T1>{
}
public class<T1,T2,T3> extends ExtendClass{
}
```` 
* 泛型的类型参数不能是简单类型，如`ArrayList<int>`会编译不过

# 多线程
# 网络通信
# 数据库操作